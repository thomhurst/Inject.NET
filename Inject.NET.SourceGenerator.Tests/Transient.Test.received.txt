[  
using System;
using System.Linq;
using System.Threading.Tasks;
using Inject.NET.Enums;
using Inject.NET.Extensions;
using Inject.NET.Services;

namespace Inject.NET.Tests;

public partial class Transient
{
	public class TransientServiceProviderServiceRegistrar : ServiceRegistrar<global::Inject.NET.Tests.Transient.TransientServiceProvider>
	{
		public TransientServiceProviderServiceRegistrar()
		{
			Register(new global::Inject.NET.Models.ServiceDescriptor
			{
				ServiceType = typeof(global::Inject.NET.Tests.Transient.TransientClass),
				ImplementationType = typeof(global::Inject.NET.Tests.Transient.TransientClass),
				Lifetime = Inject.NET.Enums.Lifetime.Transient,
				Factory = (scope, type, key) =>
				new global::Inject.NET.Tests.Transient.TransientClass()
			});

			Register(new global::Inject.NET.Models.ServiceDescriptor
			{
				ServiceType = typeof(global::Inject.NET.Tests.Transient.ClassContainingTransient),
				ImplementationType = typeof(global::Inject.NET.Tests.Transient.ClassContainingTransient),
				Lifetime = Inject.NET.Enums.Lifetime.Singleton,
				Factory = (scope, type, key) =>
				new global::Inject.NET.Tests.Transient.ClassContainingTransient(global::Inject.NET.ThrowHelpers.Throw<global::Inject.NET.Tests.Transient.TransientClass>("Injecting type TransientClass with a lifetime of Transient into an object with a lifetime of Singleton will cause it to also be Singleton"))
			});

			{
				var tenant = GetOrCreateTenant("NonOverridingTenant");
			}
			{
				var tenant = GetOrCreateTenant("OverridingTenant");
				tenant.Register(new global::Inject.NET.Models.ServiceDescriptor
				{
					ServiceType = typeof(global::Inject.NET.Tests.Transient.TransientClass),
					ImplementationType = typeof(global::Inject.NET.Tests.Transient.TransientClass),
					Lifetime = Inject.NET.Enums.Lifetime.Transient,
					Factory = (scope, type, key) =>
					new global::Inject.NET.Tests.Transient.TransientClass()
				});

				tenant.Register(new global::Inject.NET.Models.ServiceDescriptor
				{
					ServiceType = typeof(global::Inject.NET.Tests.Transient.ClassContainingTransient),
					ImplementationType = typeof(global::Inject.NET.Tests.Transient.ClassContainingTransient),
					Lifetime = Inject.NET.Enums.Lifetime.Singleton,
					Factory = (scope, type, key) =>
					new global::Inject.NET.Tests.Transient.ClassContainingTransient(global::Inject.NET.ThrowHelpers.Throw<global::Inject.NET.Tests.Transient.TransientClass>("Injecting type TransientClass with a lifetime of Transient into an object with a lifetime of Singleton will cause it to also be Singleton"))
				});

			}
		}

		public override async ValueTask<global::Inject.NET.Tests.Transient.TransientServiceProvider> BuildAsync()
{
    OnBeforeBuild(this);

    var serviceProvider = new global::Inject.NET.Tests.Transient.TransientServiceProvider(ServiceFactoryBuilders.AsReadOnly(), Tenants);
    
    var vt = serviceProvider.InitializeAsync();

    if (!vt.IsCompletedSuccessfully)
    {
        await vt.ConfigureAwait(false);
    }
    
    return serviceProvider;
}
	}
}

  
using System;
using System.Linq;
using Inject.NET.Enums;
using Inject.NET.Extensions;
using Inject.NET.Interfaces;
using Inject.NET.Models;
using Inject.NET.Services;

namespace Inject.NET.Tests;

public partial class Transient
{
	public class TransientServiceProviderSingletonScope : SingletonScope
	{
		public TransientServiceProviderSingletonScope(IServiceProviderRoot root, ServiceFactories serviceFactories) : base(root, serviceFactories)
		{
			Inject__NET__Tests__Transient__ClassContainingTransient = new global::System.Lazy<global::Inject.NET.Tests.Transient.ClassContainingTransient>(() => new global::Inject.NET.Tests.Transient.ClassContainingTransient(Inject__NET__Tests__Transient__TransientClass.Value));
			Register(new global::Inject.NET.Models.ServiceKey(typeof(global::Inject.NET.Tests.Transient.ClassContainingTransient), null), new global::System.object(() => Inject__NET__Tests__Transient__ClassContainingTransient.Value));
		}
		public global::System.Lazy<global::Inject.NET.Tests.Transient.ClassContainingTransient> Inject__NET__Tests__Transient__ClassContainingTransient { get; }
	}
}

  
using System;
using System.Linq;
using Inject.NET.Enums;
using Inject.NET.Extensions;
using Inject.NET.Interfaces;
using Inject.NET.Models;
using Inject.NET.Services;

namespace Inject.NET.Tests;

public partial class Transient
{
	public class TransientServiceProviderScope : ServiceScope
	{
		public TransientServiceProviderScope(ServiceProviderRoot root, IServiceScope singletonScope, ServiceFactories serviceFactories) : base(root, singletonScope, serviceFactories)
		{
		}
	}
}

  
using System;
using System.Threading.Tasks;
using Inject.NET.Enums;
using Inject.NET.Interfaces;

namespace Inject.NET.Tests;

public partial class Transient
{
	public partial class TransientServiceProvider : global::Inject.NET.Services.ServiceProviderRoot
	{
		public override global::Inject.NET.Tests.Transient.TransientServiceProviderSingletonScope SingletonScope { get; }
		public override IServiceScope CreateScope() => new global::Inject.NET.Tests.Transient.TransientServiceProviderScope(this, SingletonScope, ServiceFactories);
		public TransientServiceProvider(Inject.NET.Models.ServiceFactories serviceFactories, global::System.Collections.Generic.IDictionary<string, IServiceRegistrar> tenantRegistrars) : base(serviceFactories, tenantRegistrars)
		{
			SingletonScope = new(this, serviceFactories);
		}
		public static ValueTask<global::Inject.NET.Tests.Transient.TransientServiceProvider> BuildAsync() =>
			new TransientServiceProviderServiceRegistrar().BuildAsync();
	}
}

]