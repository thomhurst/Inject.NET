using Inject.NET.SourceGenerator.Helpers;
using Inject.NET.SourceGenerator.Models;
using Microsoft.CodeAnalysis;

namespace Inject.NET.SourceGenerator.Writers;

internal static class MainWriter
{
    /// <summary>
    /// Generates the complete service provider code for the given service provider model.
    /// </summary>
    /// <param name="sourceProductionContext">The source production context for adding generated files and reporting diagnostics.</param>
    /// <param name="serviceProviderModel">The typed service provider model containing metadata about the service provider.</param>
    /// <param name="compilation">The compilation context used for type resolution.</param>
    public static void GenerateServiceProviderCode(SourceProductionContext sourceProductionContext, TypedServiceProviderModel serviceProviderModel, Compilation compilation)
    {
        var sourceCodeWriter = new SourceCodeWriter();
        
        // Write file header and using statements
        sourceCodeWriter.WriteLine("// <auto-generated />");
        sourceCodeWriter.WriteLine("#pragma warning disable");
        sourceCodeWriter.WriteLine("using System;");
        sourceCodeWriter.WriteLine("using System.Diagnostics.CodeAnalysis;");
        sourceCodeWriter.WriteLine("using System.Linq;");
        sourceCodeWriter.WriteLine("using Inject.NET.Enums;");
        sourceCodeWriter.WriteLine("using Inject.NET.Extensions;");
        sourceCodeWriter.WriteLine("using Inject.NET.Interfaces;");
        sourceCodeWriter.WriteLine("using Inject.NET.Models;");
        sourceCodeWriter.WriteLine("using Inject.NET.Services;");
        sourceCodeWriter.WriteLine();

        var serviceProviderType = serviceProviderModel.Type;
        var nestedClassCount = WriteNamespaceDeclaration(sourceCodeWriter, serviceProviderType);
        
        var (rootDependencies, tenants, serviceModelCollection, decorators) = CollectDependenciesAndTenants(compilation, serviceProviderModel);
        
        // Validate service models for conflicts
        if (!ValidateServiceModels(sourceProductionContext, serviceModelCollection))
        {
            return;
        }

        sourceCodeWriter.WriteLine($"public partial class {serviceProviderType.Name}");
        sourceCodeWriter.WriteLine("{");

        GenerateProviders(sourceProductionContext, sourceCodeWriter, serviceProviderModel, serviceModelCollection, rootDependencies, tenants, decorators);
        GenerateTenantProviders(sourceCodeWriter, serviceProviderModel, serviceModelCollection, tenants);
        
        sourceCodeWriter.WriteLine(
            $"public static ValueTask<{serviceProviderModel.Prefix}ServiceProvider_> BuildAsync() =>");
        sourceCodeWriter.WriteLine($"\tnew ServiceRegistrar_().BuildAsync(null);");
        
        sourceCodeWriter.WriteLine("}");
        
        for (var i = 0; i < nestedClassCount; i++)
        {
            sourceCodeWriter.WriteLine("}");
        }

        sourceProductionContext.AddSource(
            $"{serviceProviderType.Name}ServiceProvider_{Guid.NewGuid():N}.g.cs",
            sourceCodeWriter.ToString()
        );
    }

    /// <summary>
    /// Validates all service models for conflicts and circular dependencies.
    /// </summary>
    /// <param name="sourceProductionContext">The source production context for reporting diagnostics.</param>
    /// <param name="serviceModelCollection">The collection of service models to validate.</param>
    /// <returns>True if validation passes, false if there are conflicts.</returns>
    private static bool ValidateServiceModels(SourceProductionContext sourceProductionContext, RootServiceModelCollection serviceModelCollection)
    {
        // Check root service conflicts
        if (serviceModelCollection.Services.Values
            .SelectMany(services => services)
            .Any(serviceModel => sourceProductionContext.HasConflicts(serviceModel, serviceModelCollection.Services)))
        {
            return false;
        }

        // Check tenant service conflicts
        if (serviceModelCollection.Tenants.Values
            .Any(tenant => tenant.Services.Values
                .SelectMany(services => services)
                .Any(serviceModel => sourceProductionContext.HasConflicts(serviceModel, tenant.Services))))
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Writes the namespace declaration and nested class structure for the service provider.
    /// </summary>
    /// <param name="sourceCodeWriter">The source code writer to write to.</param>
    /// <param name="serviceProviderType">The service provider type symbol.</param>
    /// <returns>The number of nested classes that need to be closed.</returns>
    private static int WriteNamespaceDeclaration(SourceCodeWriter sourceCodeWriter, INamedTypeSymbol serviceProviderType)
    {
        if (serviceProviderType.ContainingNamespace is { IsGlobalNamespace: false })
        {
            sourceCodeWriter.WriteLine($"namespace {serviceProviderType.ContainingNamespace.ToDisplayString()};");
            sourceCodeWriter.WriteLine();
        }

        var nestedClassCount = 0;
        var parent = serviceProviderType.ContainingType;

        while (parent is not null)
        {
            nestedClassCount++;
            sourceCodeWriter.WriteLine($"public partial class {parent.Name}");
            sourceCodeWriter.WriteLine("{");
            parent = parent.ContainingType;
        }

        return nestedClassCount;
    }

    /// <summary>
    /// Collects dependencies and tenants from the compilation and service provider model.
    /// </summary>
    /// <param name="compilation">The compilation context.</param>
    /// <param name="serviceProviderModel">The service provider model.</param>
    /// <returns>A tuple containing root dependencies, tenants, and the service model collection.</returns>
    private static (IDictionary<ServiceModelCollection.ServiceKey, List<ServiceModel>> rootDependencies, Tenant[] tenants, RootServiceModelCollection serviceModelCollection, IDictionary<ServiceModelCollection.ServiceKey, List<DecoratorModel>> decorators) 
        CollectDependenciesAndTenants(Compilation compilation, TypedServiceProviderModel serviceProviderModel)
    {
        var dependencyInjectionAttributeType = compilation.GetTypeByMetadataName("Inject.NET.Attributes.IDependencyInjectionAttribute");
        var withTenantAttributeType = compilation.GetTypeByMetadataName("Inject.NET.Attributes.WithTenantAttribute`1");
        var decoratorAttributeType = compilation.GetTypeByMetadataName("Inject.NET.Attributes.DecoratorAttribute");
        
        var attributes = serviceProviderModel.Type.GetAttributes();
        
        var dependencyAttributes = attributes
            .Where(x => x.AttributeClass?.AllInterfaces.Contains(dependencyInjectionAttributeType,
                SymbolEqualityComparer.Default) == true)
            .ToArray();
        
        var withTenantAttributes = attributes
            .Where(x => x.AttributeClass?.IsGenericType is true && SymbolEqualityComparer.Default.Equals(withTenantAttributeType, x.AttributeClass.OriginalDefinition))
            .ToArray();
        
        var decoratorAttributes = attributes
            .Where(x => x.AttributeClass?.BaseType != null && 
                   SymbolEqualityComparer.Default.Equals(decoratorAttributeType, x.AttributeClass.BaseType))
            .ToArray();

        var rootDependencies = DependencyDictionary.Create(compilation, dependencyAttributes, null);
        var decorators = DecoratorDictionary.Create(compilation, decoratorAttributes, null);
        var tenants = TenantHelper.ConstructTenants(compilation, withTenantAttributes, rootDependencies);
        var serviceModelCollection = TypeCollector.Collect(serviceProviderModel, compilation);

        return (rootDependencies, tenants, serviceModelCollection, decorators);
    }

    /// <summary>
    /// Generates the main service providers (ServiceProvider, Scope, SingletonScope, ServiceRegistrar).
    /// </summary>
    /// <param name="sourceProductionContext">The source production context.</param>
    /// <param name="sourceCodeWriter">The source code writer to write to.</param>
    /// <param name="serviceProviderModel">The service provider model.</param>
    /// <param name="serviceModelCollection">The collection of service models.</param>
    /// <param name="rootDependencies">The root dependency dictionary.</param>
    /// <param name="tenants">The collection of tenant definitions.</param>
    private static void GenerateProviders(SourceProductionContext sourceProductionContext, SourceCodeWriter sourceCodeWriter, 
        TypedServiceProviderModel serviceProviderModel, RootServiceModelCollection serviceModelCollection, IDictionary<ServiceModelCollection.ServiceKey, List<ServiceModel>> rootDependencies, Tenant[] tenants, IDictionary<ServiceModelCollection.ServiceKey, List<DecoratorModel>> decorators)
    {
        ServiceProviderWriter.Write(sourceProductionContext, sourceCodeWriter, serviceProviderModel, serviceModelCollection, tenants);
        SingletonScopeWriter.Write(sourceCodeWriter, serviceProviderModel, serviceModelCollection, decorators);
        ScopeWriter.Write(sourceCodeWriter, serviceProviderModel, serviceModelCollection, decorators);
        ServiceRegistrarWriter.Write(sourceCodeWriter, serviceProviderModel, rootDependencies, decorators);
    }

    /// <summary>
    /// Generates tenant-specific service providers for multi-tenant scenarios.
    /// </summary>
    /// <param name="sourceCodeWriter">The source code writer to write to.</param>
    /// <param name="serviceProviderModel">The service provider model.</param>
    /// <param name="serviceModelCollection">The collection of service models.</param>
    /// <param name="tenants">The collection of tenant definitions.</param>
    private static void GenerateTenantProviders(SourceCodeWriter sourceCodeWriter, TypedServiceProviderModel serviceProviderModel, 
        RootServiceModelCollection serviceModelCollection, Tenant[] tenants)
    {
        foreach (var tenant in tenants)
        {
            var tenantServices = serviceModelCollection.Tenants[tenant.TenantDefinition.GloballyQualified()];

            TenantServiceProviderWriter.Write(sourceCodeWriter, serviceProviderModel, serviceModelCollection, tenant);
            TenantSingletonScopeWriter.Write(sourceCodeWriter, serviceProviderModel, tenantServices);
            TenantScopeWriter.Write(sourceCodeWriter, serviceProviderModel, tenantServices);
            TenantServiceRegistrarWriter.Write(sourceCodeWriter, serviceProviderModel, tenantServices);
        }
    }
}